package oop04_Abstraction;

/*Date : 
 * Author : 
 * Desc  : 인터페이스 문법
 * 
*   추상메소드만(클래스 바디가 없고 ,메소드의 프로토타입만 선언) 으로만 이루어짐
 *  추상메소드를 사용하는 이유 : 앞으로 추가되거나 구현되여야 하는 기능의 설계 역할을 하여 실제 기능은 구현하지 않고
      메소드 프로토타입만 구현하는 것을 말함 ( 철근 , 설계도 비스무리한 개념)
 *  어떤 컴포넌트는 클래스의 이용 메소드를 공개할 목적으로 사용됨
 *  하나의 콤포넌트가 다양한 형태로 구현되어야 할 경우 인터페이스를 이용하면 콤포넌트와 사용법이 상당히 단순해짐
 *  
 *  인터페이스상에 있는 메소드를 하나라도 구현하지 않으면 인터페이스를 상속받은 클래스는 추상클래스가 됨
 *  인터페이스에 선언된 메소드를 호출하면, 그 인터페이스를 구현한 클래스의 메소드가 자동으로 호출됨
 *  인터페이스를 이용하면 인터페이스를 구현하는 클래스들은 메소드의 형태가 같기 때문에 같음 메소드 명을 이용하면서 다양한 구현을 할 수 있음
 *  이건 마치 MySql 용으로 개발된 프로그램을 Oracle용으로 변경시에 JDBC 드라이버만 변경하면 프로그램이 작동하는 것과 같은 이치
 *  인터페이스는 기능을 구현해서 가지고 있는 것이 아니라 구현되어야 하는 구조를 가지고 있음
 *  이런 이유 때문에 컴포넌트의 통일성이 향상됨
 *  
 *  인터페이스 구조
 *  -인터페이스를 이용한 메소드 호출의 경우 인터페이스타입 사용 필
 *  - 각 클래스이 멤변에 접근하는 경우 그 클래스 타입으로 형변환 해줘야 함
 *  - 인터페이스안에서는 주로 상수만 선언
 *   - 메소드만 선언하는 경우가 대부분
 *    - 인터페이스   타입 객체  = new  인터페이스  구현클래스
 *      구현클래스  i  =  (구현클래스 타입)  인터페이스 객체  
 * 
 *  
 *  cf : 안티 MS , 오라클 그룹(?)  :  티멕스, 마리아 DB(from MySql), NoSQL,
 *  콤포넌트  : 인터페이스가 바뀌면  즉 개발한 프로그램과 DB가 서로 맞지 않으면 DB 접속하는 부분(=콤포넌트)만 갈아끼움 ?? 
 *  프로토타입 :  인터페이스 내부에 있는 일종의  원형 ?   = 샘플링 ( 외부모형)
 */

public class InterfaceSyntax {

}
